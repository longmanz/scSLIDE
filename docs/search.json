[{"path":"/articles/scSLIDE_COVID19.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick start with scSLIDE","text":"vignette walks Single-cell Sample-Level Integration using Density Estimation (scSLIDE) workflow, novel computational method performs sample-level analysis single-cell data. Given multi-sample single-cell disease data, workflow first obtains cell-type-oriented embedding (via reference mapping unsupervised dimension reduction) disease-oriented embedding (via supervised learning). constructs joint embedding two embeddings cells embedded joint space distances reflect cell-type disease-state similarity. Next, adopt landmark-based strategy (originally proposed Yi & Stanley et al bioRxiv), using randomly sketched subset cells (‘landmarks’) quantify cell density near landmark sample. end landmark--donor matrix whose entries represent cell density near landmark donor. Sample-level analyses pseudo-trajectory inference pseudobulk differential expression testing can performed based sample-level object (also shown ).","code":""},{"path":"/articles/scSLIDE_COVID19.html","id":"setup-and-library-loading","dir":"Articles","previous_headings":"","what":"Setup and Library Loading","title":"Quick start with scSLIDE","text":"First, load necessary libraries set working environment.","code":"# some other packages that will be used in this vignette can be installed using the following commands: # devtools::install_github(\"satijalab/AzimuthAPI\") # devtools::install_github(\"xmc811/Scillus\", ref = \"development\") # BiocManager::install(\"destiny\") # install.packages(c(\"princurve\", \"ggridges\"))  library(Seurat) # make sure this is the scSLIDE-compatible version library(scSLIDE) library(AzimuthAPI) library(princurve) library(ggplot2) library(ggridges) library(Scillus)  # set the future.globals.maxSize to 5GB options(future.globals.maxSize = 5 * 1000 * 1024^2)"},{"path":"/articles/scSLIDE_COVID19.html","id":"data-loading-and-initial-processing","dir":"Articles","previous_headings":"","what":"Data Loading and Initial Processing","title":"Quick start with scSLIDE","text":"use subset (~104k cells) Ahern et al 2022 Cell example workflow. subset can downloaded link. dataset consists 40 donors: 10 healthy controls (‘HV’) 10 patients 3 different COVID severity groups (“MILD”, “SEV”, “CRIT”).","code":"object <- readRDS(\"Raw_count_Subset_104k_Ahern_2022_Cell.rds\") object <- NormalizeData(object)"},{"path":"/articles/scSLIDE_COVID19.html","id":"cell-type-annotation-with-azimuth","dir":"Articles","previous_headings":"","what":"Cell Type Annotation with Azimuth","title":"Quick start with scSLIDE","text":"use pan-human Azimuth cloud tool annotate data obtain cell-type-oriented embedding. Alternatively, users can employ methods like PCA different integration methods obtain embedding, later manually annotate cell types.","code":"object <- CloudAzimuth(object)  # Get the top 2000 highly variable genes  object <- FindVariableFeatures(object, nfeatures = 2000)"},{"path":"/articles/scSLIDE_COVID19.html","id":"prepare-the-single-cell-data-for-sample-level-analysis","dir":"Articles","previous_headings":"","what":"Prepare the Single-Cell Data for Sample-Level Analysis","title":"Quick start with scSLIDE","text":"perform necessary pre-processing steps, provide wrapper function called PrepareSampleObject(). function prepares single-cell Seurat object downstream sample-level density analysis. (optionally) identifies additional highly variable genes correlation testing, creates training landmark cell subsets via sketching methods, performs PLS learning capture response-relevant variation, constructs weighted multi-modal nearest neighbor graph landmark cells full dataset. function outputs prepared Seurat object containing landmark assay cell--landmark WNN graph needed subsequent sample object generation. PrepareSampleObject() function comprehensive wrapper streamlines data preparation process four key steps: Training subset creation: Performs uniform sketching obtain representative training subset efficient PLS learning (optional) Landmark cell selection: Uses leverage-score sketching identify diverse subset landmark cells capture dataset’s heterogeneity Response-oriented embedding: Conducts PLS learning generate embeddings capture variation relevant specified response variable Neighbor graph construction: Builds weighted multi-modal nearest neighbor graph connecting landmark cells cells dataset resulting neighbor graph serves foundation generating sample-level landmark matrices downstream analysis. users need fine-grained control individual parameters, following step--step workflow demonstrates manually execute component PrepareSampleObject() custom settings.","code":"object <- PrepareSampleObject(object = object,                               assay = \"RNA\",                               add.hvg = T,                               group.by.CorTest = \"azimuth_label\",                               Y = \"Disease\",                               sketch.training = T,                               group.by.Sketch = \"Donor\",                               ncells.per.group = 1000,                               ncells.landmark = 2000,                               ncomp = 20,                               pls.function = \"cppls\",                               k.nn = 5,                               name.reduction.1 = \"azimuth_embed\",                               dims.reduction.1 = 1:128,                              fix.wnn.weights = c(0.5, 0.5),                               verbose = T)"},{"path":"/articles/scSLIDE_COVID19.html","id":"data-sketching-procedures","dir":"Articles","previous_headings":"Prepare the Single-Cell Data for Sample-Level Analysis","what":"Data Sketching Procedures","title":"Quick start with scSLIDE","text":"Next, begin sketching data using two different procedures. first sketching procedure obtains random subset cells donor (e.g., n = 1000), ensuring number cells approximately equal among donors supervised learning. step optional users believe cell numbers already balanced, recommend efficiency considerations. second sketching procedure performs leverage score-based sketching select representative subset cells (called landmark cells) covers diverse cell states data. Later, generate sample-level embeddings using landmarks.","code":"object = SketchDataByGroup(object, assay = \"RNA\", ncells = 1000, sketched.assay = \"TRAINING\",                            method = \"Uniform\", group.by = \"Donor\", verbose = FALSE) object = SketchData(object, assay = \"TRAINING\", ncells = 2000, sketched.assay = \"LANDMARK\",                     method = \"LeverageScore\", verbose = FALSE)"},{"path":"/articles/scSLIDE_COVID19.html","id":"disease-relevant-gene-selection","dir":"Articles","previous_headings":"Prepare the Single-Cell Data for Sample-Level Analysis","what":"Disease-Relevant Gene Selection","title":"Quick start with scSLIDE","text":"can obtain additional disease-relevant genes enhance PLS learning (case HVGs always relevant). users believe variable features already sufficiently informative, can omit step.","code":"deg_list = QuickCorTest(object, assay = \"TRAINING\", layer = \"data\", group.by = \"azimuth_label\", Y = \"Disease\", cor.cutoff = 0.2, verbose = FALSE) all_HVG = union(VariableFeatures(object), deg_list)"},{"path":"/articles/scSLIDE_COVID19.html","id":"supervised-learning-with-partial-least-squares-pls","dir":"Articles","previous_headings":"Prepare the Single-Cell Data for Sample-Level Analysis","what":"Supervised Learning with Partial Least Squares (PLS)","title":"Quick start with scSLIDE","text":"apply supervised learning PLS TRAINING data obtain disease-oriented low-dimensional embeddings. RunPLS() supports 3 different PLS algorithms: standard PLS (‘plsr’), canonical PLS (‘cppls’), sparse PLS (‘spls’). Please check manual RunPLS() details.","code":"DefaultAssay(object) = \"TRAINING\" object = ScaleData(object, features = all_HVG) object = RunPLS(object = object, assay = \"TRAINING\", features = all_HVG,                  ncomp = 20,                  Y = c(\"Disease\"),                  pls.function = \"cppls\",                 verbose = FALSE)"},{"path":"/articles/scSLIDE_COVID19.html","id":"projection-to-full-dataset","dir":"Articles","previous_headings":"Prepare the Single-Cell Data for Sample-Level Analysis","what":"Projection to Full Dataset","title":"Quick start with scSLIDE","text":"Now project learned PLS full dataset append projected PLS embeddings.","code":"proj.pls <- ProjectCellEmbeddings(   query = object,   query.assay = \"RNA\",   reference = object,   reference.assay = \"TRAINING\",   reduction = \"pls\",   dims = 1:20,   scale = T,   normalization.method = \"LogNormalize\",   verbose = T )  # Append the projected PLS embeddings to the full data object[['proj.pls']] <- CreateDimReducObject(embeddings = proj.pls, key = \"pPLS_\", assay = \"RNA\") rm(proj.pls) gc()"},{"path":"/articles/scSLIDE_COVID19.html","id":"joint-embedding-construction-with-weighted-nearest-neighbors","dir":"Articles","previous_headings":"Prepare the Single-Cell Data for Sample-Level Analysis","what":"Joint Embedding Construction with Weighted Nearest Neighbors","title":"Quick start with scSLIDE","text":"obtaining cell-type-oriented embeddings disease-oriented embeddings, now generate joint embedding account types information, placing cells joint space distances reflect similarity. use weighted nearest neighbors (WNN) procedure originally developed Hao & Hao et al Cell 2021. Instead running original WNN procedure, modify ‘modality weights’ 2 embeddings fixed 0.5, ensuring contribute equally WNN embedding (users can modify values let algorithm learn dynamically). function return WNN graph ‘landmark cells’ cells dataset. Note step time-consuming, single-cell data large (≥ 200k), please consider using future R package parallelization. Click collapse ▲","code":"DefaultAssay(object) = \"RNA\"  object = FindmmNN(object,                   sketch.assay = \"LANDMARK\",                   reduction.list = list(\"azimuth_embed\", \"proj.pls\"),                   k.nn = 5,                   weighted.nn.name = \"weighted.nn\",                   dims.list = list(1:128, 1:20),                   fix.wnn.weights = c(0.5, 0.5))"},{"path":"/articles/scSLIDE_COVID19.html","id":"sample-level-object-generation","dir":"Articles","previous_headings":"","what":"Sample-Level Object Generation","title":"Quick start with scSLIDE","text":"WNN graph constructed, can generate sample-level density matrix. Given asymmetric landmark--cell WNN graph, scSLIDE aggregates cells obtain landmark--sample density matrix (m landmarks n samples) binarizing adjacency (neighbor = 1, else 0) summing per sample. entry landmark--sample matrix measures cell density near landmark given donor. function GenerateSampleObject() automatically generates sample-level object based WNN object specified nn.name =. Additionally, helps users search donor-level metadata original single-cell object append sample-level object (optional). also performs Chi-squared normalization (based Poisson distribution contingency table) count matrix (optional; standard log-normalization also supported).","code":"sample_obj = GenerateSampleObject(object = object,                                    sketch.assay = \"LANDMARK\",                                    nn.name = \"weighted.nn\",                                    group.by = \"Donor\",                                    rename.group.by = \"azimuth_label\",                                    k.nn = 5,                                    normalization.method = \"ChiSquared\",                                   add.meta.data = TRUE,                                   return.seurat = T) # Center the data sample_obj = ScaleData(sample_obj, features = rownames(sample_obj), do.scale = F, do.center = T)"},{"path":"/articles/scSLIDE_COVID19.html","id":"diffusion-map-analysis","dir":"Articles","previous_headings":"","what":"Diffusion Map Analysis","title":"Quick start with scSLIDE","text":"better denoise sample-level data, instead performing standard PCA, perform Diffusion Map (non-linear unsupervised dimensional reduction method originally proposed Haghverdi et al Bioinformatics capture single-cell trajectories). visualizing Diffusion Map components, can see DC1 captures case-control status, DC2 captures COVID heterogeneity (related severity), DC3 captures COVID severity.  append DC1-3 metadata analyze relationships clinical variables. following plots show DC2 related TimeSinceOnset DC3 related severity:","code":"sample_obj = RunDiffusionMap(sample_obj, assay = \"LMC\", layer = \"scale.data\", features = rownames(sample_obj), ncomp = 10) DimPlot(sample_obj, reduction = \"DiffMap\", group.by = \"Disease\") +   DimPlot(sample_obj, reduction = \"DiffMap\", group.by = \"Disease\", dims = c(1, 3)) # Append DC1-3 to the metadata sample_obj[['traj_DC1']] = sample_obj@reductions$DiffMap@cell.embeddings[, 1] sample_obj[['traj_DC2']] = sample_obj@reductions$DiffMap@cell.embeddings[, 2] sample_obj[['traj_DC3']] = sample_obj@reductions$DiffMap@cell.embeddings[, 3] # Showing DC2 is related to TimeSinceOnset and DC3 is related to severity p1 = FeatureScatter(sample_obj,                 feature1 = \"traj_DC2\",                 feature2 = \"TimeSinceOnset\",                 group.by = \"Disease\",                 cells = colnames(sample_obj)[sample_obj$Disease != \"HV\"],                 pt.size = 2)  p2 = ggplot(sample_obj@meta.data[sample_obj$Disease != \"HV\", ]) +   geom_density_ridges(aes(x = traj_DC3, y = Disease, fill = Disease), scale = 0.9) +    theme_minimal() +   theme(title = element_text(hjust = 0.5, size = 15),          text = element_text(size = 13),          axis.text.x = element_text(hjust = 1, vjust = 1, angle = 45),         axis.text = element_text(size = 13))  print(p1 + p2) #> Picking joint bandwidth of 0.0286"},{"path":"/articles/scSLIDE_COVID19.html","id":"principal-curve-fitting","dir":"Articles","previous_headings":"Diffusion Map Analysis","what":"Principal Curve Fitting","title":"Quick start with scSLIDE","text":"want explore multiple DCs merged together, can also fit principal curve top DCs obtain joint pseudo-trajectory line. fitting curve top 2 DCs, append object.","code":"princurve_res = princurve::principal_curve(sample_obj[['DiffMap']]@cell.embeddings[, 1:2],                                            plot = F, maxit = 20, trace = T) sample_obj[['traj_overall']] = princurve_res$lambda DimPlot(sample_obj, reduction = \"DiffMap\", group.by = \"Disease\")  +   geom_path(aes(x = princurve_res$s[princurve_res$ord, 1], y = princurve_res$s[princurve_res$ord, 2]))"},{"path":"/articles/scSLIDE_COVID19.html","id":"differential-expression-analysis-setup","dir":"Articles","previous_headings":"","what":"Differential Expression Analysis Setup","title":"Quick start with scSLIDE","text":"Finally, can perform differential expression (DE) analysis extract differentially expressed genes (DEGs) change along pseudo-trajectory inferred. individual DC separately, since believe represent 3 different biological variations. First, need obtain pseudobulked expression data original single-cell data:","code":"bulk_obj = AggregateExpression(object, assays = \"RNA\", group.by = c(\"Donor\", \"azimuth_label\"), return.seurat = T) #> Centering and scaling data matrix # Append the metadata to pseudobulked object  mdata = object@meta.data[, c(\"Donor\", \"azimuth_label\")] mdata = mdata[!duplicated(mdata), ] rownames(mdata) = paste0(gsub(pattern = \"_\", replacement = \"-\", mdata$Donor),                          \"_\",                          gsub(pattern = \"_\", replacement = \"-\", mdata$azimuth_label)) bulk_obj = AddMetaData(bulk_obj, metadata  = mdata)  bulk_obj$nCount_RNA = colSums(x = bulk_obj, slot = \"counts\")  # nCount_RNA bulk_obj$nFeature_RNA = colSums(x = LayerData(object = bulk_obj, layer = \"counts\") > 0)  # nFeatureRNA"},{"path":"/articles/scSLIDE_COVID19.html","id":"de-analysis-for-cd14-monocytes","dir":"Articles","previous_headings":"Differential Expression Analysis Setup","what":"DE Analysis for CD14 Monocytes","title":"Quick start with scSLIDE","text":"run DE analysis one cell type time. use “CD14 monocytes” example. can now run trajectory DE tests DC1, DC2, DC3, respectively. Note remove healthy donors focusing DC2/3 better focus within-COVID heterogeneity. Now, DE results, identify top - -regulated DEGs visualization: Heatmap visualization DC1 (donors ordered based DC1):  Heatmap visualization DC2 DC3 (healthy donors removed):","code":"sub_bulk_obj = subset(bulk_obj, subset = azimuth_label == \"CD14 monocyte\")  # Add metadata from sample-level object to pseudobulk object new_mdata = merge(sub_bulk_obj@meta.data[, c(\"Donor\"), drop = F],                   sample_obj@meta.data[, c(\"Donor\", \"Age\", \"Sex\", \"Disease\", \"traj_DC1\", \"traj_DC2\", \"traj_DC3\")],                   by = \"Donor\",                   all.x = T,                   sort = FALSE) sub_bulk_obj = AddMetaData(sub_bulk_obj, metadata = new_mdata) sub_bulk_obj$log_count = log10(sub_bulk_obj$nCount_RNA) # Run trajectory DE test for DC1 de_results = TrajDETest(sub_bulk_obj, assay = \"RNA\", layer = \"counts\",                         traj.var = \"traj_DC1\", latent.vars = c(\"Age\", \"Sex\", \"log_count\"))  # Run trajectory DE tests for DC2 and DC3 non_health_idx = Cells(sub_bulk_obj)[sub_bulk_obj$Disease != \"HV\"] de_results2 = TrajDETest(sub_bulk_obj, assay = \"RNA\", layer = \"counts\",                          traj.var = \"traj_DC2\", latent.vars = c(\"Age\", \"Sex\", \"log_count\"),                          samples = non_health_idx)  de_results3 = TrajDETest(sub_bulk_obj, assay = \"RNA\", layer = \"counts\",                          traj.var = \"traj_DC3\", latent.vars = c(\"Age\", \"Sex\", \"log_count\"),                          samples = non_health_idx) # Identify the top up- and down-regulated DEGs for visualization de_results$sign = sign(de_results$beta_Traj) de_results = de_results[order(de_results$sign, de_results$p_Traj), ] DEG_DC1 = c(de_results$gene_ID[de_results$sign > 0][1:20],              de_results$gene_ID[de_results$sign < 0][20:1])  de_results2$sign = sign(de_results2$beta_Traj) de_results2 = de_results2[order(de_results2$sign, de_results2$p_Traj), ] DEG_DC2 = c(de_results2$gene_ID[de_results2$sign > 0][1:20],              de_results2$gene_ID[de_results2$sign < 0][20:1])  de_results3$sign = sign(de_results3$beta_Traj) de_results3 = de_results3[order(de_results3$sign, de_results3$p_Traj), ] DEG_DC3 = c(de_results3$gene_ID[de_results3$sign > 0][1:20],              de_results3$gene_ID[de_results3$sign < 0][20:1]) # Heatmap visualization for DC1 (donors are ordered based on DC1) sub_bulk_obj = ScaleData(sub_bulk_obj, features = DEG_DC1) Scillus::plot_heatmap(dataset = sub_bulk_obj,                       markers = DEG_DC1,                       sort_var = \"traj_DC1\",                       anno_var = c(\"Disease\"),                       anno_colors = list(c(\"#f8766d\", \"cornsilk\", \"#7cae02\", \"blue1\", \"#01bfc4\", \"#c77cff\" )),                       hm_colors = c(\"blue\",\"white\",\"red\")) # Heatmap visualization for DC2 and DC3 (healthy donors are removed) sub_bulk_obj2 = subset(sub_bulk_obj, cells = non_health_idx) sub_bulk_obj2 = ScaleData(sub_bulk_obj2, features = c(DEG_DC1, DEG_DC2, DEG_DC3)) Scillus::plot_heatmap(dataset = sub_bulk_obj2,                       markers = DEG_DC2,                       sort_var = \"traj_DC2\",                       anno_var = c(\"Disease\"),                       anno_colors = list(c(\"cornsilk\", \"#7cae02\", \"blue1\", \"#01bfc4\", \"#c77cff\" )),                       hm_colors = c(\"blue\",\"white\",\"red\")) Scillus::plot_heatmap(dataset = sub_bulk_obj2,                       markers = DEG_DC3,                       sort_var = \"traj_DC3\",                       anno_var = c(\"Disease\"),                       anno_colors = list(c(\"cornsilk\", \"#7cae02\", \"blue1\", \"#01bfc4\", \"#c77cff\" )),                       hm_colors = c(\"blue\",\"white\",\"red\"))"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Longda Jiang. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jiang L (2025). scSLIDE: Single Cell Sketching Landmark Integrated Dimensional Embedding. R package version 0.1.0, https://github.com/satijalab/scSLIDE.","code":"@Manual{,   title = {scSLIDE: Single Cell Sketching and Landmark Integrated Dimensional Embedding},   author = {Longda Jiang},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/satijalab/scSLIDE}, }"},{"path":"/index.html","id":"scslide","dir":"","previous_headings":"","what":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"Single-cell Sample-Level Integration using Density Estimation scSLIDE R package perform sample-level analysis multi-sample single-cell RNA sequencing data. leverages semi-supervised dimensional reduction framework embed cells latent space robustly retains underlying type- state-identity well phenotype-driven differences. sample represented probability distribution cellular states, yielding sample-level representation can directly used clustering, trajectory inference, integrative analyses.","code":""},{"path":[]},{"path":"/index.html","id":"dimensionality-reduction","dir":"","previous_headings":"Key Features","what":"Dimensionality Reduction","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"RunPLS: Partial Least Squares (PLS) dimensionality reduction support plsr, spls, cppls methods RunDiffusionMap: Diffusion map analysis trajectory inference","code":""},{"path":"/index.html","id":"sample-level-analysis","dir":"","previous_headings":"Key Features","what":"Sample-Level Analysis","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"PrepareSampleObject: Comprehensive workflow preparing single-cell data sample-level analysis GenerateSampleObject: Generate sample-level count matrices single-cell data","code":""},{"path":"/index.html","id":"novel-differential-expression-test","dir":"","previous_headings":"Key Features","what":"Novel Differential Expression Test","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"TrajDETest: Trajectory-based differential expression analysis using negative binomial regression","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"","code":"# Install BiocManager if not already installed if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  # Install Bioconductor dependencies manually BiocManager::install(c(\"glmGamPoi\", \"destiny\"))  # Install SeuratObject  install.packages(\"SeuratObject\")  # Install Seurat from a developmental branch that is compatible with scSLIDE (built upon v5.3.1)  remotes::install_github(\"satijalab/seurat\", \"v5.3.1_scSLIDE_compatible\")  # Install scSLIDE from GitHub devtools::install_github(\"longmanz/scSLIDE\")"},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"scSLIDE depends : - Seurat (>= 5.3.1): Core single-cell analysis framework - SeuratObject (>= 5.2.0): Seurat object structure - pls: Partial least squares regression - spls: Sparse partial least squares - glmGamPoi: Gamma-Poisson regression DE analysis - destiny: Diffusion map analysis - ggplot2, dplyr, tidyr, RColorBrewer: Visualization data manipulation","code":""},{"path":"/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"use scSLIDE research, please cite:","code":"[Citation information to be added]"},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"MIT License - see LICENSE file details.","code":""},{"path":"/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"Single Cell Sketching and Landmark Integrated Dimensional Embedding","text":"questions support, please open issue GitHub repository.","code":""},{"path":"/reference/BuildLandmarkObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a landmark object with correlation analysis and UMAP embedding — BuildLandmarkObject","title":"Build a landmark object with correlation analysis and UMAP embedding — BuildLandmarkObject","text":"Build landmark object correlation analysis UMAP embedding","code":""},{"path":"/reference/BuildLandmarkObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a landmark object with correlation analysis and UMAP embedding — BuildLandmarkObject","text":"","code":"BuildLandmarkObject(   object = NULL,   sample.obj = NULL,   rename.sample = NULL,   weighted.nn.name = \"weighted.nn\",   landmark.assay.name = \"LANDMARK\",   features.to.test = NULL,   k.nn = 20,   min.dist = 0.3,   ... )"},{"path":"/reference/BuildLandmarkObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a landmark object with correlation analysis and UMAP embedding — BuildLandmarkObject","text":"object Seurat object sample.obj Sample-level Seurat object rename.sample Optional renaming samples weighted.nn.name Name weighted nearest neighbor object landmark.assay.name Name landmark assay features..test Features test correlation k.nn Number nearest neighbors min.dist Minimum distance UMAP ... Additional arguments","code":""},{"path":"/reference/BuildLandmarkObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a landmark object with correlation analysis and UMAP embedding — BuildLandmarkObject","text":"Landmark object UMAP correlation data","code":""},{"path":"/reference/FindmmNN.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Multi-Modal Nearest Neighbors — FindmmNN","title":"Find Multi-Modal Nearest Neighbors — FindmmNN","text":"wrapper function finds Multi-Modal weights generate Multi-Modal NN object.","code":""},{"path":"/reference/FindmmNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Multi-Modal Nearest Neighbors — FindmmNN","text":"","code":"FindmmNN(   object,   sketch.assay = NULL,   reduction.list,   dims.list,   k.nn = 20,   knn.range = 200,   l2.norm = TRUE,   fix.wnn.weights = NULL,   weighted.nn.name = \"weighted.nn\",   verbose = TRUE,   ... )"},{"path":"/reference/FindmmNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Multi-Modal Nearest Neighbors — FindmmNN","text":"object Seurat object sketch.assay name sketched assay landmark cells. reduction.list list dimensional reductions, one modality dims.list list containing dimensions reduction use k.nn number nearest neighbors compute modality knn.range Range parameter nearest neighbor search l2.norm Perform L2 normalization cell embeddings fix.wnn.weights Pre-specified modality weights. provided, skips calculation uses weights directly. list length reduction.list. weighted.nn.name Multimodal neighbor object name verbose Print progress bars output ... Arguments passed methods","code":""},{"path":"/reference/FindmmNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Multi-Modal Nearest Neighbors — FindmmNN","text":"return Seurat object contains weighted.nn Neighbor object landmark cells cells.","code":""},{"path":"/reference/FindmmNN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find Multi-Modal Nearest Neighbors — FindmmNN","text":"function essentially wrapper function perform following 2 procedures: Seurat:::FindModalityWeights Seurat:::MultiModalNN","code":""},{"path":"/reference/GenerateSampleObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a sample-level count matrix based on landmark assay and its weighted.nn object — GenerateSampleObject","title":"Generate a sample-level count matrix based on landmark assay and its weighted.nn object — GenerateSampleObject","text":"Returns summed counts weighted.nn landmark cell within sample.","code":""},{"path":"/reference/GenerateSampleObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a sample-level count matrix based on landmark assay and its weighted.nn object — GenerateSampleObject","text":"","code":"GenerateSampleObject(   object,   nn.name = NULL,   k.nn = 5,   sketch.assay = \"LANDMARK\",   return.seurat = TRUE,   new_assay_name = \"LMC\",   group.by = \"ident\",   normalization.method = \"ChiSquared\",   scale.factor = 10000,   rename.group.by = NULL,   add.meta.data = TRUE,   remove.sketch.cell.from.col = TRUE,   verbose = TRUE,   ... )"},{"path":"/reference/GenerateSampleObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a sample-level count matrix based on landmark assay and its weighted.nn object — GenerateSampleObject","text":"object Seurat object nn.name Name Neighbor object use calculation k.nn number nearest neighbors perform summing sketch.assay name sketch.assay used perform FindmmNN() return.seurat Whether return data Seurat object. Default TRUE new_assay_name Name new assay containing landmark counts group.Category (vector categories) grouping (e.g, Donor ID); 'ident' default use multiple categories, specify vector, c('batch', 'replicate') normalization.method Method normalization. Supports LogNormalize ChiSquared. see details NormalizeData NormalizeChiSquared scale.factor Scale factor Log-Normalization, see NormalizeData rename.group.rename.group.NULL, rownames landmark matrix used original cell IDs. , user can indicate meta-data column use rename rows. suffix \"_LM\" + order number added automatically. add.meta.data TRUE, function automatically detect sample-level meta-data (based 'group.') append sample-level object; FALSE, . remove.sketch.cell..col TRUE, function detect columns NN object remove cells used landmark cells. verbose Print progress diagnostic messages ... Arguments passed methods CreateSeuratObject","code":""},{"path":"/reference/GenerateSampleObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a sample-level count matrix based on landmark assay and its weighted.nn object — GenerateSampleObject","text":"return Seurat object contains count matrix number landmark rows, sample columns","code":""},{"path":"/reference/NormalizeChiSquared.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Chi-squared normalization to a Seurat object — NormalizeChiSquared","title":"Apply Chi-squared normalization to a Seurat object — NormalizeChiSquared","text":"function applies Chi-squared normalization (sample-level) Seurat object. calculates expected density (count cells) landmark-sample pair assuming random distribution, normalizes observed counts using: (observed - expected) / √(expected). resulting values show much landmark's density deviates expected baseline—density values. Positive values indicate higher--expected density, negative values indicate lower--expected expression.","code":""},{"path":"/reference/NormalizeChiSquared.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Chi-squared normalization to a Seurat object — NormalizeChiSquared","text":"","code":"NormalizeChiSquared(object, ...)  # Default S3 method NormalizeChiSquared(object = NULL, verbose = TRUE, ...)  # S3 method for class 'Assay' NormalizeChiSquared(object, verbose = TRUE, ...)  # S3 method for class 'StdAssay' NormalizeChiSquared(   object,   layer = \"counts\",   save = \"data\",   verbose = TRUE,   ... )  # S3 method for class 'Seurat' NormalizeChiSquared(object, assay = NULL, verbose = TRUE, ...)"},{"path":"/reference/NormalizeChiSquared.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Chi-squared normalization to a Seurat object — NormalizeChiSquared","text":"object count matrix (landmark-sample density matrix), Assay, StdAssay, Seurat object ... Additional arguments verbose display progress bar normalization procedure layer Layer use (StdAssay objects) save Layer save results (StdAssay objects) assay Name assay use (Seurat objects)","code":""},{"path":"/reference/NormalizeChiSquared.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Chi-squared normalization to a Seurat object — NormalizeChiSquared","text":"Normalized object class input","code":""},{"path":"/reference/NormalizeChiSquared.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Chi-squared normalization to a Seurat object — NormalizeChiSquared","text":"","code":"if (FALSE) { # \\dontrun{ # Normalize a sample-level Seurat object sample_obj <- NormalizeChiSquared(sample_obj) } # }"},{"path":"/reference/PlotLandmarkObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize landmark-trajectory correlations with UMAP plots — PlotLandmarkObject","title":"Visualize landmark-trajectory correlations with UMAP plots — PlotLandmarkObject","text":"Visualize landmark-trajectory correlations UMAP plots","code":""},{"path":"/reference/PlotLandmarkObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize landmark-trajectory correlations with UMAP plots — PlotLandmarkObject","text":"","code":"PlotLandmarkObject(   landmark_obj,   order = TRUE,   pt.size = 0.5,   alpha = 0.8,   plot.featureplot = FALSE,   ncol = NULL )"},{"path":"/reference/PlotLandmarkObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize landmark-trajectory correlations with UMAP plots — PlotLandmarkObject","text":"landmark_obj Landmark object BuildLandmarkObject order Whether order points expression pt.size Point size plots alpha Point transparency plot.featureplot Whether create feature plots ncol Number columns faceting","code":""},{"path":"/reference/PlotLandmarkObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize landmark-trajectory correlations with UMAP plots — PlotLandmarkObject","text":"List ggplot objects","code":""},{"path":"/reference/PrepareSampleObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform preprocessing procedures for a Seurat object to prepare for the sample-level analysis — PrepareSampleObject","title":"Perform preprocessing procedures for a Seurat object to prepare for the sample-level analysis — PrepareSampleObject","text":"wrapper function apply landmark sketching, training data sketching (optional), PLS learning, weighted nearest neighbor (WNN) workflow single-cell Seurat object get necessary components sample-level analyses later. output object can directly used GenerateSampleObject obtain sample-level matrix.","code":""},{"path":"/reference/PrepareSampleObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform preprocessing procedures for a Seurat object to prepare for the sample-level analysis — PrepareSampleObject","text":"","code":"PrepareSampleObject(   object = NULL,   assay = NULL,   add.hvg = TRUE,   group.by.CorTest = NULL,   Y = NULL,   sketch.training = TRUE,   group.by.Sketch = NULL,   ncells.per.group = 1000,   training.assay.name = \"TRAINING\",   training.sketch.method = \"Uniform\",   ncells.landmark = 2000,   landmark.assay.name = \"LANDMARK\",   landmark.sketch.method = \"LeverageScore\",   ncomp = 10,   pls.function = c(\"plsr\", \"spls\", \"cppls\"),   pls.reduction.name = \"pls\",   k.nn = 5,   name.reduction.1 = \"pca\",   dims.reduction.1 = 1:30,   weighted.nn.name = \"weighted.nn\",   fix.wnn.weights = c(0.5, 0.5),   rm.training.assay = FALSE,   max_core = 1,   future.memory.per.core = 2000,   verbose = TRUE,   ... )"},{"path":"/reference/PrepareSampleObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform preprocessing procedures for a Seurat object to prepare for the sample-level analysis — PrepareSampleObject","text":"object Seurat object. assay assay perform analyses add.hvg boolen specify whether function runs additional correlation test features response (Y) obtain response-relevant features included VariableFeatures used PLS learning. See QuickCorTest details. Default TRUE. group..CorTest metadata column name group cells QuickCorTest. NULL, falls back QuickCorTest without grouping. Default NULL. Y metadata column name responses. also used responses PLS learning. sketch.training boolen specify whether function performs sketching Seurat object get training subset PLS learning (PLS learned subset projected full data). efficiency, recommended Seurat object large. 'assay' specified Seurat object -disk assay, parameter must set TRUE. Default FALSE. group..Sketch metadata column name group cells sketching. NULL, falls back standard sketching without grouping. Default NULL. ncells.per.group positive integer, named vector, list specifying number cells sample. Default 1000 per category 'group..Sketch'. See SketchDataByGroup detailed usage. training.assay.name assay name training data. training.sketch.method Sketching method use training subset. Can 'LeverageScore' 'Uniform'. Default 'Uniform' training want obtain unbiased subset original data. See LeverageScore details. ncells.landmark positive integer specifying number 'landmark cells'. function generate new assay 'landmark cells' (please confuse training subset). landmark cells subset covers diverse cell types cell states data. Default 2000. landmark.assay.name assay name landmark cells. Default \"LANDMARK\". landmark.sketch.method Sketching method use landmark cells. Can 'LeverageScore' 'Uniform'. Default 'LeverageScore' want landmark cells diverse/representative possible. See LeverageScore details. ncomp Number components compute pls.function PLS function pls package run (options: plsr, spls, cppls) pls.reduction.name PLS dimensional reduction name k.nn number nearest neighbors compute modality name.reduction.1 name DimReduc use 1st embedding (2nd PLS embedding) WNN process. dims.reduction.1 dimensions reduction.1 use WNN process. weighted.nn.name Multimodal neighbor object name fix.wnn.weights Pre-specified modality weights. provided, skips calculation uses weights directly. list length reduction.list. rm.training.assay Whether remove training assay running PrepareSampleObject(). used reduce memory usage seurat object large (e.g., large -disk object). Default FALSE. max_core number cores use parallelization running WNN process (processes). Note user already set \"future::plan()\" running function, ignore parameter respect user's future plan (plan() applied functions called, including ScaleData()). Default 1 sequential processing. future.memory.per.core memory allocation per core options(future.globals.maxSize = ...), calculation future.globals.maxSize = max_core × future.memory.per.core × 1024 × 1024 bytes. Default 2000 (unit MB). verbose Print progress diagnostic messages ... Arguments passed methods","code":""},{"path":"/reference/PrepareSampleObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform preprocessing procedures for a Seurat object to prepare for the sample-level analysis — PrepareSampleObject","text":"return Seurat object contains weighted.nn Neighbor object landmark cells cells. Seurat object also contain landmark assay (training assay sketch.training == TRUE).","code":""},{"path":"/reference/QuickCorTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform cor.test between each gene and a response variable given a Seurat object — QuickCorTest","title":"Perform cor.test between each gene and a response variable given a Seurat object — QuickCorTest","text":"function take Seurat object's gene expression matrix meta-data column (response variable), run cor.test gene response variable keep track top-correlated genes return gene list user. intended give users response-informative gene list downstream supervised dimension reduction analyses like partial least squares.","code":""},{"path":"/reference/QuickCorTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform cor.test between each gene and a response variable given a Seurat object — QuickCorTest","text":"","code":"QuickCorTest(   object = NULL,   assay = NULL,   layer = \"data\",   group.by = NULL,   Y = NULL,   cor.cutoff = NULL,   top.prop = 0.01,   min.pct = 0.1,   min.cells = 100,   verbose = TRUE,   unlist = TRUE,   ... )"},{"path":"/reference/QuickCorTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform cor.test between each gene and a response variable given a Seurat object — QuickCorTest","text":"object Seurat object assay name assay retrieve expression matrix layer name layer use cor.test group.metadata column name group cells cor.test. NULL, falls back cor.test without grouping. Default NULL. Y metadata column name responses. cor.cutoff correlation coefficient cutoff select top genes. Default NULL. top.prop proportion genes selected top genes, cor.cutoff provided. Can used together cor.cutoff, NULL time. Default 0.01, .e. correlated 1% genes selected. min.pct test genes detected minimum fraction min.pct cells group. Default 0.1 min.cells minimum number cells per group perform cor.test. Default 100. groups < 100 skipped. verbose Print progress bars output unlist whether return unlist object (vector) named list (element vector DEGs category group.) ... Additional arguments","code":""},{"path":"/reference/QuickCorTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform cor.test between each gene and a response variable given a Seurat object — QuickCorTest","text":"return list gene names genes highly correlated responses","code":""},{"path":"/reference/QuickCorTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform cor.test between each gene and a response variable given a Seurat object — QuickCorTest","text":"","code":"if (FALSE) { # \\dontrun{ # Find genes correlated with pseudotime cor_genes <- QuickCorTest(seurat_obj, Y = \"pseudotime\") } # }"},{"path":"/reference/RunAndProjectUMAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a UMAP for a sketched assay and then project it to the full data. — RunAndProjectUMAP","title":"Generate a UMAP for a sketched assay and then project it to the full data. — RunAndProjectUMAP","text":"wrapper function builds ProjectUMAP() function, allows users generate UMAP subset data (e.g., cells sketched assay), project UMAP data.","code":""},{"path":"/reference/RunAndProjectUMAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a UMAP for a sketched assay and then project it to the full data. — RunAndProjectUMAP","text":"","code":"RunAndProjectUMAP(   object,   nn.name = NULL,   k.nn = 5,   landmark.assay.name = \"LANDMARK\",   reduction.name = \"sketched.umap\",   verbose = TRUE,   ... )"},{"path":"/reference/RunAndProjectUMAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a UMAP for a sketched assay and then project it to the full data. — RunAndProjectUMAP","text":"object Seurat object nn.name name Neighbor object used generate UMAP. k.nn number neighbors used genearte UMAP. exceeds number k nn.name object, ignored. landmark.assay.name name sketched assay reduction.name name UMAP stored; Note projected UMAP named \"proj.'reduction.name'\". verbose Print progress status ... parameters accepted RunUMAP() ProjectUMAP()","code":""},{"path":"/reference/RunAndProjectUMAP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a UMAP for a sketched assay and then project it to the full data. — RunAndProjectUMAP","text":"return Seurat object contains UMAP sketched assay UMAP full data","code":""},{"path":"/reference/RunDiffusionMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Diffusion Map — RunDiffusionMap","title":"Run Diffusion Map — RunDiffusionMap","text":"Run diffusion map dimensionality reduction single-cell data.","code":""},{"path":"/reference/RunDiffusionMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Diffusion Map — RunDiffusionMap","text":"","code":"RunDiffusionMap(object, ...)  # Default S3 method RunDiffusionMap(   object,   assay = NULL,   metric = \"cosine\",   distance.matrix = NULL,   ncomp = 20,   reduction.name = \"DiffMap\",   reduction.key = \"DC_\",   weight.by.var = TRUE,   verbose = TRUE,   seed.use = 101,   ... )  # S3 method for class 'Assay' RunDiffusionMap(   object,   assay = NULL,   features = NULL,   ncomp = 20,   metric = \"cosine\",   distance.matrix = NULL,   reduction.name = \"DiffMap\",   reduction.key = \"DC_\",   weight.by.var = TRUE,   verbose = TRUE,   seed.use = 101,   ... )  # S3 method for class 'StdAssay' RunDiffusionMap(   object,   assay = NULL,   features = NULL,   layer = \"scale.data\",   ncomp = 20,   metric = \"cosine\",   distance.matrix = NULL,   reduction.name = \"DiffMap\",   reduction.key = \"DC_\",   weight.by.var = TRUE,   verbose = TRUE,   seed.use = 101,   ... )  # S3 method for class 'Seurat' RunDiffusionMap(   object,   assay = NULL,   features = NULL,   layer = \"scale.data\",   ncomp = 20,   metric = \"cosine\",   distance.matrix = NULL,   reduction.name = \"DiffMap\",   reduction.key = \"DC_\",   weight.by.var = TRUE,   verbose = TRUE,   seed.use = 101,   ... )"},{"path":"/reference/RunDiffusionMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Diffusion Map — RunDiffusionMap","text":"object object run diffusion map ... Additional arguments passed DiffusionMap() assay Name Assay diffusion map run metric determines choice metric used measure distance input space. Check DiffusionMap() details. distance.matrix provided, ignored. distance.matrix set, runs DiffusionMap given distance matrix instead data matrix. ncomp Number components compute reduction.name name DimReduc object reduction.key dimensional reduction key, specifies string number dimension names. weight..var Weight cell embeddings variance PC verbose print diagnostic messages. Default TRUE. seed.use Set random seed.  Setting NULL set seed. features Features compute Diffusion Map layer layer assay use running diffusion map analysis.","code":""},{"path":"/reference/RunDiffusionMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Diffusion Map — RunDiffusionMap","text":"Returns DimReduc object diffusion map results","code":""},{"path":"/reference/RunDiffusionMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Diffusion Map — RunDiffusionMap","text":"","code":"if (FALSE) { # \\dontrun{ # Run diffusion map on a Seurat object seurat_obj <- RunDiffusionMap(seurat_obj, ncomp = 10) } # }"},{"path":"/reference/RunPLS.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Partial Least Squares (PLS) on Seurat Objects — RunPLS","title":"Run Partial Least Squares (PLS) on Seurat Objects — RunPLS","text":"Performs Partial Least Squares regression analysis single-cell data. function provides methods plsr, spls, cppls pls spls packages.","code":""},{"path":"/reference/RunPLS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Partial Least Squares (PLS) on Seurat Objects — RunPLS","text":"","code":"RunPLS(object, ...)  # Default S3 method RunPLS(   object,   assay = NULL,   ncomp = 20,   Y = NULL,   Y.add = NULL,   pls.function = c(\"plsr\", \"spls\", \"cppls\"),   verbose = TRUE,   ndims.print = 1:5,   nfeatures.print = 30,   reduction.name = \"pls\",   reduction.key = \"PLS_\",   seed.use = 42,   eta = 0.5,   ... )  # S3 method for class 'Assay' RunPLS(   object,   assay = NULL,   features = NULL,   ncomp = 20,   Y = NULL,   Y.add = NULL,   pls.function = c(\"plsr\", \"spls\", \"cppls\"),   verbose = TRUE,   ndims.print = 1:5,   nfeatures.print = 30,   reduction.name = \"pls\",   reduction.key = \"PLS_\",   seed.use = 42,   eta = 0.5,   ... )  # S3 method for class 'StdAssay' RunPLS(   object,   assay = NULL,   features = NULL,   layer = \"scale.data\",   ncomp = 20,   Y = NULL,   Y.add = NULL,   pls.function = c(\"plsr\", \"spls\", \"cppls\"),   verbose = TRUE,   ndims.print = 1:5,   nfeatures.print = 30,   reduction.name = \"pls\",   reduction.key = \"PLS_\",   seed.use = 42,   eta = 0.5,   ... )  # S3 method for class 'Seurat' RunPLS(   object,   assay = NULL,   features = NULL,   ncomp = 20,   Y = NULL,   Y.add = NULL,   pls.function = c(\"plsr\", \"spls\", \"cppls\"),   verbose = TRUE,   ndims.print = 1:5,   nfeatures.print = 30,   reduction.name = \"pls\",   reduction.key = \"PLS_\",   seed.use = 42,   eta = 0.5,   ... )"},{"path":"/reference/RunPLS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Partial Least Squares (PLS) on Seurat Objects — RunPLS","text":"object object run PLS ... Additional arguments passed PLS function assay Name Assay PLS run ncomp Number components compute Y vector matrix responses, .e., dependent variable PLS regresses X . length / number rows number cells. Y can multiple columns. Y.add vector matrix additional responses containing relevant information observations. used cppls. pls.function PLS function pls package run (options: plsr, spls, cppls) verbose Print top genes associated high/low loadings components ndims.print components print genes nfeatures.print Number genes print component reduction.name name DimReduc object reduction.key dimensional reduction key, specifies string number dimension names. seed.use Set random seed.  Setting NULL set seed. eta Thresholding parameter controls sparsity spls method (larger –> sparser). eta 0 1. features Features compute PLS layer layer assay use running PLS analysis.","code":""},{"path":"/reference/RunPLS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Partial Least Squares (PLS) on Seurat Objects — RunPLS","text":"Returns DimReduc object PLS results","code":""},{"path":"/reference/RunPLS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Partial Least Squares (PLS) on Seurat Objects — RunPLS","text":"","code":"if (FALSE) { # \\dontrun{ # Run PLS on a Seurat object seurat_obj <- RunPLS(seurat_obj, Y = \"condition\", ncomp = 10) } # }"},{"path":"/reference/SampleLevelDimPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize the landmark-trajectory relevance and the sample-level cell density — SampleLevelDimPlot","title":"Visualize the landmark-trajectory relevance and the sample-level cell density — SampleLevelDimPlot","text":"Visualize landmark-trajectory relevance sample-level cell density","code":""},{"path":"/reference/SampleLevelDimPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize the landmark-trajectory relevance and the sample-level cell density — SampleLevelDimPlot","text":"","code":"SampleLevelDimPlot(   object = NULL,   sample.obj = NULL,   rename.sample = NULL,   weighted.nn.name = \"weighted.nn\",   landmark.assay.name = \"LANDMARK\",   features.to.test = NULL,   order = TRUE,   pt.size = 0.5,   alpha = 0.8,   ncol = NULL,   return.seurat.obj = TRUE,   k.nn = 20,   min.dist = 0.3,   ... )"},{"path":"/reference/SampleLevelDimPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize the landmark-trajectory relevance and the sample-level cell density — SampleLevelDimPlot","text":"object Seurat object sample.obj Sample-level Seurat object rename.sample Optional sample renaming weighted.nn.name Name weighted NN object landmark.assay.name Name landmark assay features..test Features test correlation order Whether order points pt.size Point size alpha Point transparency ncol Number columns return.seurat.obj Whether return Seurat object k.nn Number nearest neighbors min.dist Minimum distance UMAP ... Additional arguments","code":""},{"path":"/reference/SampleLevelDimPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize the landmark-trajectory relevance and the sample-level cell density — SampleLevelDimPlot","text":"List containing plots optionally landmark object","code":""},{"path":"/reference/SketchDataByGroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Sketch Data by Group — SketchDataByGroup","title":"Sketch Data by Group — SketchDataByGroup","text":"function uses sketching methods downsample high-dimensional single-cell RNA expression data within specified groups/categories, can help scalability large datasets maintaining representation across different cell types conditions.","code":""},{"path":"/reference/SketchDataByGroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sketch Data by Group — SketchDataByGroup","text":"","code":"SketchDataByGroup(   object,   group.by = NULL,   assay = NULL,   ncells = 1000L,   sketched.assay = \"sketch\",   method = c(\"Uniform\", \"LeverageScore\"),   var.name = \"leverage.score\",   cells = NULL,   over.write = FALSE,   seed = 123L,   cast = \"dgCMatrix\",   verbose = TRUE,   features = NULL,   min.cells.per.group = 10L,   ... )"},{"path":"/reference/SketchDataByGroup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sketch Data by Group — SketchDataByGroup","text":"object Seurat object. group.metadata column name group cells sketching. NULL, falls back standard sketching without grouping. Default NULL. assay Assay name. Default NULL, case default assay object used. ncells positive integer, named vector, list specifying number cells sample. single integer: number cells sampled group layer named vector group names: specific number per group named list group names containing layer vectors: specific number per group per layer Default 1000. sketched.assay Sketched assay name. sketch assay created overwritten sketch data. Default 'sketch'. method Sketching method use. Can 'LeverageScore' 'Uniform'. Default 'Uniform'. var.name metadata column name store leverage scores. Default 'leverage.score'. cells vector contains IDs cells user wants keep. set, user-defined cells directly used generate sketch, ignoring group.parameter. .write Whether overwrite existing column metadata. Default FALSE. seed positive integer seed random number generator. Default 123. cast type cast resulting assay . Default 'dgCMatrix'. verbose Print progress diagnostic messages. Default TRUE. features character vector feature names include sketched assay. min.cells.per.group Minimum number cells required per group perform sketching. Groups fewer cells included entirely. Default 10. ... Arguments passed methods","code":""},{"path":"/reference/SketchDataByGroup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sketch Data by Group — SketchDataByGroup","text":"Seurat object sketched data added new assay. metadata contain information groups sketched cell belongs .","code":""},{"path":"/reference/SketchDataByGroup.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sketch Data by Group — SketchDataByGroup","text":"group.specified, function performs following steps: Splits cells groups based metadata column Calculates leverage scores (method = 'LeverageScore') within group Samples specified number cells group Combines sampled cells sketched assay approach ensures rare cell types conditions underrepresented final sketched dataset.","code":""},{"path":"/reference/SketchDataByGroup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sketch Data by Group — SketchDataByGroup","text":"","code":"if (FALSE) { # \\dontrun{ # Basic usage with grouping by cell type sketched_obj <- SketchDataByGroup(   object = seurat_obj,   group.by = \"cell_type\",   ncells = 500 )  # Different number of cells per group sketched_obj <- SketchDataByGroup(   object = seurat_obj,   group.by = \"condition\",   ncells = c(\"control\" = 1000, \"treatment\" = 800) )  # Without grouping (falls back to original behavior) sketched_obj <- SketchDataByGroup(   object = seurat_obj,   ncells = 5000 ) } # }"},{"path":"/reference/TrajDETest.html","id":null,"dir":"Reference","previous_headings":"","what":"Trajectory Differential Expression Test — TrajDETest","title":"Trajectory Differential Expression Test — TrajDETest","text":"Perform trajectory-based differential expression analysis using negative binomial regression. function tests genes change expression along continuous trajectory variable.","code":""},{"path":"/reference/TrajDETest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trajectory Differential Expression Test — TrajDETest","text":"","code":"TrajDETest(object, ...)  # Default S3 method TrajDETest(   object,   traj.var = NULL,   latent.vars = NULL,   features = NULL,   fc.results = NULL,   verbose = TRUE,   ... )  # S3 method for class 'Assay' TrajDETest(   object,   layer = \"counts\",   traj.var = NULL,   latent.vars = NULL,   samples = NULL,   features = NULL,   logfc.threshold = 0,   prob.break.point = c(1/3, 2/3),   min.pct = 0.1,   min.count = 10,   pseudocount.use = 1,   verbose = TRUE,   ... )  # S3 method for class 'StdAssay' TrajDETest(   object,   layer = \"counts\",   traj.var = NULL,   latent.vars = NULL,   samples = NULL,   features = NULL,   logfc.threshold = 0,   prob.break.point = c(1/3, 2/3),   min.pct = 0.1,   min.count = 10,   pseudocount.use = 1,   verbose = TRUE,   ... )  # S3 method for class 'Seurat' TrajDETest(   object,   assay = NULL,   layer = \"counts\",   traj.var = NULL,   latent.vars = NULL,   samples = NULL,   features = NULL,   logfc.threshold = 0,   prob.break.point = c(1/3, 2/3),   min.pct = 0.1,   min.count = 10,   pseudocount.use = 1,   complete.resutls = FALSE,   verbose = TRUE,   ... )"},{"path":"/reference/TrajDETest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trajectory Differential Expression Test — TrajDETest","text":"object Expression data matrix, Assay, StdAssay, Seurat object ... additional parameters passed glmGamPoi::glm_gp filterByExpr traj.var data frame containing trajectory variable samples tested latent.vars data frame containing latent variables (e.g., covariates might affect gene expression) include regression. features Genes test. Default use genes (QC) fc.results fc.results calculated FoldChange(); null QC performed based verbose Print progress bar expression testing begins layer data layer used trajectory DE test. Currently 'counts' supported. samples cells/samples included DE test logfc.threshold Limit testing genes show, average, least X-fold difference (log-scale) top bottom groups samples (see pro.break.point details). Default 0 (.e., filtering). prob.break.point numeric vector probability break points values (0, 1). used calculate 2 quantiles along trajectory calculate logfc. min.pct test genes detected minimum fraction min.pct cells either two populations. min.count Minimum count threshold gene filtering pseudocount.use Pseudocount add averaged expression values calculating logFC. 1 default. assay assay used (Seurat objects) complete.resutls Whether return complete results summary","code":""},{"path":"/reference/TrajDETest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trajectory Differential Expression Test — TrajDETest","text":"data frame differential expression results","code":""},{"path":"/reference/TrajDETest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trajectory Differential Expression Test — TrajDETest","text":"","code":"if (FALSE) { # \\dontrun{ # Run trajectory DE test on a Seurat object de_results <- TrajDETest(seurat_obj, traj.var = \"pseudotime\") } # }"},{"path":"/reference/cellanova_calc_BE.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform CellAnova Batch correction — cellanova_calc_BE","title":"Perform CellAnova Batch correction — cellanova_calc_BE","text":"CellAnova (Zhaojun Zhang et al, 2024 Nat Biotech) new method can remove/mitigate batch effect single-cell data return users \"corrected\" data matrix (instead just low-dim embedding). implement 2nd step CellAnova. Specifically, function R-implemention CellAnova python package's calc_BE() function (https://github.com/Janezjz/cellanova).","code":""},{"path":"/reference/cellanova_calc_BE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform CellAnova Batch correction — cellanova_calc_BE","text":"","code":"cellanova_calc_BE(   object = NULL,   assay = NULL,   layer = \"scale.data\",   integrate_key = NULL,   features = NULL,   control_dict = NULL,   reduction = NULL,   var_cutoff = 0.9,   k_max = 1500,   k_select = NULL,   new.assay.name = \"CORRECTED\",   verbose = TRUE )"},{"path":"/reference/cellanova_calc_BE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform CellAnova Batch correction — cellanova_calc_BE","text":"object Seurat object assay name assay perform CellAnova correction. layer name layer used correct batch effect. scale.data. integrate_key string indicating smallest batch unit meta-data (e.g., library, donor, etc.), used integration later. features features compute corrected expression . Defaults variable features set assay specified. control_dict list indicating control-group assignment controls. name element list correspond batch name 'integrate_key' column. reduction name DimReduc object use integrated embeddings. methods like Harmony Seurat-integration methods (e.g., CCA). var_cutoff fraction explained variance determine optimal value k truncated SVD calculating basis batch effect. Default 0.9. k_max maximum singular values vectors compute. k_select user-defined number singular values vectors compute (override var_cutoff k_max). Default NULL. new.assay.name name new assay store corrected expression matrix verbose display progress + messages","code":""},{"path":"/reference/cellanova_calc_BE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform CellAnova Batch correction — cellanova_calc_BE","text":"Returns Seurat object new assay added containing batch-corrected expression matrix","code":""},{"path":"/reference/cellanova_calc_BE.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform CellAnova Batch correction — cellanova_calc_BE","text":"function takes Seurat object pre-computed integrated embedding methods like Harmony Seurat-CCA, batch-effect index, case-control index input, estimate batch effect control samples, correct full original expression data. procedures kept , following modifications: currently support one control group. additionally implemented future_lapply() efficient regression framework enhance efficiency. procedure can done \"sketched\" data later project whole data (purposes efficiency data balance).","code":""},{"path":"/reference/scSLIDE-package.html","id":null,"dir":"Reference","previous_headings":"","what":"scSLIDE: Single Cell Sketching and Landmark Integrated Dimensional Embedding — scSLIDE-package","title":"scSLIDE: Single Cell Sketching and Landmark Integrated Dimensional Embedding — scSLIDE-package","text":"scSLIDE extends Seurat advanced functionality single-cell RNA sequencing analysis, including partial least squares (PLS) dimensionality reduction, enhanced sketching methods, trajectory analysis, sample-level aggregation methods large-scale single-cell datasets.","code":""},{"path":"/reference/scSLIDE-package.html","id":"key-functions","dir":"Reference","previous_headings":"","what":"Key Functions","title":"scSLIDE: Single Cell Sketching and Landmark Integrated Dimensional Embedding — scSLIDE-package","text":"RunPLS Perform Partial Least Squares dimensionality reduction SketchDataByGroup Enhanced sketching group-aware sampling FindmmNN Find multi-modal nearest neighbors PrepareSampleObject Prepare data sample-level analysis GenerateSampleObject Generate sample-level count matrices TrajDETest Trajectory-based differential expression analysis QuickCorTest Fast correlation testing genes responses NormalizeChiSquared Chi-squared normalization sample-level data RunDiffusionMap Diffusion map dimensionality reduction","code":""},{"path":"/reference/scSLIDE-package.html","id":"visualization-functions","dir":"Reference","previous_headings":"","what":"Visualization Functions","title":"scSLIDE: Single Cell Sketching and Landmark Integrated Dimensional Embedding — scSLIDE-package","text":"BuildLandmarkObject Build landmark objects visualization PlotLandmarkObject Plot landmark-trajectory correlations SampleLevelDimPlot Sample-level visualization RunAndProjectUMAP Generate project UMAP embeddings","code":""},{"path":[]},{"path":"/reference/scSLIDE-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"scSLIDE: Single Cell Sketching and Landmark Integrated Dimensional Embedding — scSLIDE-package","text":"Maintainer: Longda Jiang ljiang@nygenome.org (ORCID)","code":""}]
